diff -ru ./modules/ssl/mod_ssl.c ./modules/ssl/mod_ssl.c
--- ./modules/ssl/mod_ssl.c	2015-01-16 16:51:56.000000000 +0100
+++ ./modules/ssl/mod_ssl.c	2015-01-16 16:50:25.000000000 +0100
@@ -417,32 +417,32 @@
     return 1;
 }
 
-static int modssl_register_npn(conn_rec *c, 
-                               ssl_npn_advertise_protos advertisefn,
-                               ssl_npn_proto_negotiated negotiatedfn)
-{
-#ifdef HAVE_TLS_NPN
-    SSLConnRec *sslconn = myConnConfig(c);
-
-    if (!sslconn) {
-        return DECLINED;
-    }
-
-    if (!sslconn->npn_advertfns) {
-        sslconn->npn_advertfns = 
-            apr_array_make(c->pool, 5, sizeof(ssl_npn_advertise_protos));
-        sslconn->npn_negofns = 
-            apr_array_make(c->pool, 5, sizeof(ssl_npn_proto_negotiated));
-    }
-
-    if (advertisefn)
-        APR_ARRAY_PUSH(sslconn->npn_advertfns, ssl_npn_advertise_protos) =
-            advertisefn;
-    if (negotiatedfn)
-        APR_ARRAY_PUSH(sslconn->npn_negofns, ssl_npn_proto_negotiated) =
-            negotiatedfn;
-
-    return OK;
+static int modssl_register_alpn(conn_rec *c,
+                               ssl_alpn_propose_protos advertisefn,
+                               ssl_alpn_proto_negotiated negotiatedfn)
+{
+#if defined(HAVE_ALPN_NPN) || defined(HAVE_TLS_NPN)
+	SSLConnRec *sslconn = myConnConfig(c);
+	
+	if (!sslconn) {
+		return DECLINED;
+	}
+	
+	if (!sslconn->alpn_proposefns) {
+		sslconn->alpn_proposefns =
+		apr_array_make(c->pool, 5, sizeof(ssl_alpn_propose_protos));
+		sslconn->alpn_negofns =
+		apr_array_make(c->pool, 5, sizeof(ssl_alpn_proto_negotiated));
+	}
+	
+	if (advertisefn)
+		APR_ARRAY_PUSH(sslconn->alpn_proposefns, ssl_alpn_propose_protos) =
+			advertisefn;
+	if (negotiatedfn)
+		APR_ARRAY_PUSH(sslconn->alpn_negofns, ssl_alpn_proto_negotiated) =
+			negotiatedfn;
+	
+	return OK;
 #else
     return DECLINED;
 #endif
@@ -610,7 +610,7 @@
 
     APR_REGISTER_OPTIONAL_FN(ssl_proxy_enable);
     APR_REGISTER_OPTIONAL_FN(ssl_engine_disable);
-    APR_REGISTER_OPTIONAL_FN(modssl_register_npn);
+    APR_REGISTER_OPTIONAL_FN(modssl_register_alpn);
 
     ap_register_auth_provider(p, AUTHZ_PROVIDER_GROUP, "ssl",
                               AUTHZ_PROVIDER_VERSION,
diff -ru ./modules/ssl/mod_ssl.h ./modules/ssl/mod_ssl.h
--- ./modules/ssl/mod_ssl.h	2015-01-16 16:51:56.000000000 +0100
+++ ./modules/ssl/mod_ssl.h	2015-01-16 16:50:25.000000000 +0100
@@ -63,40 +63,46 @@
 
 APR_DECLARE_OPTIONAL_FN(int, ssl_engine_disable, (conn_rec *));
 
-/** The npn_advertise_protos callback allows another modules to add
- * entries to the list of protocol names advertised by the server
- * during the Next Protocol Negotiation (NPN) portion of the SSL
- * handshake.  The callback is given the connection and an APR array;
- * it should push one or more char*'s pointing to NUL-terminated
- * strings (such as "http/1.1" or "spdy/2") onto the array and return
- * OK.  To prevent further processing of (other modules') callbacks,
- * return DONE. */
-typedef int (*ssl_npn_advertise_protos)(conn_rec *connection, 
-                                        apr_array_header_t *protos);
+/** The alpn_propose_proto callback allows other modules to propose
+ * the name of the protocol that will be chosen during the
+ * Application-Layer Protocol Negotiation (ALPN) portion of the SSL handshake.
+ * The callback is given the connection and a list of NULL-terminated
+ * protocol strings as supported by the client.  If this client_protos is 
+ * non-empty, it must pick its preferred protocol from that list. Otherwise
+ * it should add its supported protocols in order of precedence.
+ * The callback should not yet modify the connection or install any filters
+ * as its proposal(s) may be overridden by another callback or server 
+ * configuration. 
+ * It should return OK or, to prevent further processing of (other modules') 
+ * callbacks, return DONE.
+ */
+typedef int (*ssl_alpn_propose_protos)(conn_rec *connection,
+									apr_array_header_t *client_protos,
+									apr_array_header_t *proposed_protos);
 
-/** The npn_proto_negotiated callback allows other modules to discover
- * the name of the protocol that was chosen during the Next Protocol
- * Negotiation (NPN) portion of the SSL handshake.  Note that this may
- * be the empty string (in which case modules should probably assume
- * HTTP), or it may be a protocol that was never even advertised by
- * the server.  The callback is given the connection, a
+/** The alpn_proto_negotiated callback allows other modules to discover
+ * the name of the protocol that was chosen during the Application-Layer
+ * Protocol Negotiation (ALPN) portion of the SSL handshake.  
+ * The callback is given the connection, a
  * non-NUL-terminated string containing the protocol name, and the
  * length of the string; it should do something appropriate
- * (i.e. insert or remove filters) and return OK.  To prevent further
+ * (i.e. insert or remove filters) and return OK. To prevent further
  * processing of (other modules') callbacks, return DONE. */
-typedef int (*ssl_npn_proto_negotiated)(conn_rec *connection, 
+typedef int (*ssl_alpn_proto_negotiated)(conn_rec *connection,
                                         const char *proto_name,
                                         apr_size_t proto_name_len);
 
-/* An optional function which can be used to register a pair of
- * callbacks for NPN handling.  This optional function should be
- * invoked from a pre_connection hook which runs *after* mod_ssl.c's
- * pre_connection hook.  The function returns OK if the callbacks are
- * register, or DECLINED otherwise (for example if mod_ssl does not
- * support NPN).  */
-APR_DECLARE_OPTIONAL_FN(int, modssl_register_npn, (conn_rec *conn, 
-                                                   ssl_npn_advertise_protos advertisefn,
-                                                   ssl_npn_proto_negotiated negotiatedfn));
+/* An optional function which can be used to register a pair of callbacks 
+ * for ALPN handling.
+ * This optional function should be invoked from a pre_connection hook 
+ * which runs *after* mod_ssl.c's pre_connection hook.  The function returns 
+ * OK if the callbacks are registered, or DECLINED otherwise (for example if 
+ * mod_ssl does not support ALPN).
+ */
+APR_DECLARE_OPTIONAL_FN(int, modssl_register_alpn,
+						(conn_rec *conn,
+						 ssl_alpn_propose_protos proposefn,
+						 ssl_alpn_proto_negotiated negotiatedfn));
 
 #endif /* __MOD_SSL_H__ */
 /** @} */
diff -ru ./modules/ssl/ssl_engine_init.c ./modules/ssl/ssl_engine_init.c
--- ./modules/ssl/ssl_engine_init.c	2015-01-16 16:51:56.000000000 +0100
+++ ./modules/ssl/ssl_engine_init.c	2015-01-16 16:50:25.000000000 +0100
@@ -614,7 +614,10 @@
 
     SSL_CTX_set_info_callback(ctx, ssl_callback_Info);
 
-#ifdef HAVE_TLS_NPN
+#if defined(HAVE_TLS_ALPN)
+	SSL_CTX_set_alpn_select_cb(
+	   ctx, ssl_callback_alpn_select, NULL);
+#elif defined(HAVE_TLS_NPN)
     SSL_CTX_set_next_protos_advertised_cb(
         ctx, ssl_callback_AdvertiseNextProtos, NULL);
 #endif
diff -ru ./modules/ssl/ssl_engine_io.c ./modules/ssl/ssl_engine_io.c
--- ./modules/ssl/ssl_engine_io.c	2015-01-16 16:51:56.000000000 +0100
+++ ./modules/ssl/ssl_engine_io.c	2015-01-16 16:50:25.000000000 +0100
@@ -298,7 +298,7 @@
     apr_pool_t *pool;
     char buffer[AP_IOBUFSIZE];
     ssl_filter_ctx_t *filter_ctx;
-    int npn_finished;  /* 1 if NPN has finished, 0 otherwise */
+    int alpn_finished;  /* 1 if ALPN has finished, 0 otherwise */
 } bio_filter_in_ctx_t;
 
 /*
@@ -1414,35 +1414,41 @@
         APR_BRIGADE_INSERT_TAIL(bb, bucket);
     }
 
-#ifdef HAVE_TLS_NPN
-    /* By this point, Next Protocol Negotiation (NPN) should be completed (if
-     * our version of OpenSSL supports it).  If we haven't already, find out
-     * which protocol was decided upon and inform other modules by calling
-     * npn_proto_negotiated_hook. */
-    if (!inctx->npn_finished) {
-        SSLConnRec *sslconn = myConnConfig(f->c);
-        const unsigned char *next_proto = NULL;
-        unsigned next_proto_len = 0;
-        int n;
-
-        if (sslconn->npn_negofns) {
-            SSL_get0_next_proto_negotiated(
-                inctx->ssl, &next_proto, &next_proto_len);
-            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, f->c,
-                          APLOGNO(02306) "SSL NPN negotiated protocol: '%*s'",
-                          next_proto_len, (const char*)next_proto);
-            
-            for (n = 0; n < sslconn->npn_negofns->nelts; n++) {
-                ssl_npn_proto_negotiated fn = 
-                    APR_ARRAY_IDX(sslconn->npn_negofns, n, ssl_npn_proto_negotiated);
-                
-                if (fn(f->c, (const char *)next_proto, next_proto_len) == DONE)
-                    break;
-            }
-        }
-            
-        inctx->npn_finished = 1;
-    }
+#if defined(HAVE_TLS_ALPN) || defined(HAVE_TLS_NPN)
+	/* By this point, Application-Layer Protocol Negotiation (ALPN) should be 
+	 * completed (if our version of OpenSSL supports it). If we haven't already, 
+	 * find out which protocol was decided upon and inform other modules 
+	 * by calling alpn_proto_negotiated_hook. 
+	 */
+	if (!inctx->alpn_finished) {
+		SSLConnRec *sslconn = myConnConfig(f->c);
+		const unsigned char *next_proto = NULL;
+		unsigned next_proto_len = 0;
+		int n;
+		
+		if (sslconn->alpn_negofns) {
+	#ifdef HAVE_TLS_ALPN
+			SSL_get0_alpn_selected(inctx->ssl, &next_proto, &next_proto_len);
+			ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, f->c,
+						  APLOGNO(02306) "SSL ALPN negotiated protocol: '%*s'",
+						  next_proto_len, (const char*)next_proto);
+	#else
+			SSL_get0_next_proto_negotiated(
+										   inctx->ssl, &next_proto, &next_proto_len);
+			ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, f->c,
+						  APLOGNO(02306) "SSL NPN negotiated protocol: '%*s'",
+						  next_proto_len, (const char*)next_proto);
+	#endif
+			for (n = 0; n < sslconn->alpn_negofns->nelts; n++) {
+				ssl_alpn_proto_negotiated fn =
+				APR_ARRAY_IDX(sslconn->alpn_negofns, n, ssl_alpn_proto_negotiated);
+				
+				if (fn(f->c, (const char *)next_proto, next_proto_len) == DONE)
+				break;
+			}
+		}
+		inctx->alpn_finished = 1;
+	}
 #endif
 
     return APR_SUCCESS;
@@ -1926,7 +1932,7 @@
     inctx->block = APR_BLOCK_READ;
     inctx->pool = c->pool;
     inctx->filter_ctx = filter_ctx;
-    inctx->npn_finished = 0;
+    inctx->alpn_finished = 0;
 }
 
 /* The request_rec pointer is passed in here only to ensure that the
diff -ru ./modules/ssl/ssl_engine_kernel.c ./modules/ssl/ssl_engine_kernel.c
--- ./modules/ssl/ssl_engine_kernel.c	2015-01-16 16:51:56.000000000 +0100
+++ ./modules/ssl/ssl_engine_kernel.c	2015-01-16 16:50:25.000000000 +0100
@@ -2131,7 +2131,137 @@
 }
 #endif /* HAVE_TLS_SESSION_TICKETS */
 
-#ifdef HAVE_TLS_NPN
+#ifdef HAVE_TLS_ALPN
+
+/*
+ * Compare to ALPN protocol proposal. Result is similar to strcmp():
+ * 0 gives same precedence, >0 means proto1 is prefered.
+ */
+static int ssl_cmp_alpn_protos(conn_rec *c,
+							   const unsigned char *proto1,
+							   const unsigned char *proto2)
+{
+	/* TODO: we should have a mod_ssl configuration parameter. */
+	return strcmp((const char *)proto1, (const char *)proto2);
+}
+
+static int ssl_array_index(apr_array_header_t *array,
+						   const unsigned char *s)
+{
+	int i;
+	for (i = 0; i < array->nelts; i++) {
+		const unsigned char *p = APR_ARRAY_IDX(array, i, const unsigned char*);
+		if (!strcmp((const char *)p, (const char *)s)) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+/*
+ * This callback function is executed when the TLS Application Layer
+ * Protocol Negotiate Extension (ALPN, RFC 7301) is triggered by the client 
+ * hello, giving a list of desired protocol names (in descending preference) 
+ * to the server.
+ * The callback has to select a protocol name or return an error if none of
+ * the clients preferences is supported. 
+ * The selected protocol does not have to be on the client list, according
+ * to RFC 7301, so no checks are performed.
+ * The client protocol list is serialized as length byte followed by ascii
+ * characters (not null-terminated), followed by the next protocol name.
+ */
+int ssl_callback_alpn_select(SSL *ssl,
+							 const unsigned char **out, unsigned char *outlen,
+							 const unsigned char *in, unsigned int inlen, void *arg)
+{
+	conn_rec *c = (conn_rec*)SSL_get_app_data(ssl);
+	SSLConnRec *sslconn = myConnConfig(c);
+	const unsigned char *alpn_http1 = (const unsigned char*)"http/1.1";
+	apr_array_header_t *client_protos;
+	apr_array_header_t *proposed_protos;
+	int i;
+
+	/* If the connection object is not available,
+	 * then there's nothing for us to do. */
+	if (c == NULL) {
+		return SSL_TLSEXT_ERR_OK;
+	}
+	
+	if (inlen == 0) {
+		// someone tries to trick us?
+		ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(02306)
+					  "alpn client protocol list empty");
+		return SSL_TLSEXT_ERR_ALERT_FATAL;
+	}
+	
+	client_protos = apr_array_make(c->pool, 0, sizeof(char *));
+	for (i = 0; i < inlen; /**/) {
+		unsigned int plen = in[i++];
+		if (plen + i > inlen) {
+			// someone tries to trick us?
+			ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(02306)
+						  "alpn protocol identier too long");
+			return SSL_TLSEXT_ERR_ALERT_FATAL;
+		}
+		APR_ARRAY_PUSH(client_protos, char*) =
+			apr_pstrndup(c->pool, (const char *)in+i, plen);
+		i += plen;
+	}
+	
+	/* Regardless of installed hooks, the http/1.1 protocol is always
+	 * supported by us. Add it to the proposals if the client also
+	 * offers it. */
+	proposed_protos = apr_array_make(c->pool, client_protos->nelts+1,
+									 sizeof(char *));
+	if (ssl_array_index(client_protos, alpn_http1) >= 0) {
+		APR_ARRAY_PUSH(proposed_protos, const unsigned char*) = alpn_http1;
+	}
+	
+	if (sslconn->alpn_proposefns != NULL) {
+		/* Invoke our alpn_propos_proto hooks, giving other modules a chance to
+		 * propose protocol names for selection. We might have several such
+		 * hooks installed and if two make a proposal, we need to give 
+		 * preference to one.
+		 */
+		for (i = 0; i < sslconn->alpn_proposefns->nelts; i++) {
+			ssl_alpn_propose_protos fn =
+				APR_ARRAY_IDX(sslconn->alpn_proposefns, i,
+							  ssl_alpn_propose_protos);
+			
+			if (fn(c, client_protos, proposed_protos) == DONE)
+				break;
+		}
+	}
+
+	if (proposed_protos->nelts <= 0) {
+		ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(02306)
+					  "none of the client alpn protocols are supported");
+		return SSL_TLSEXT_ERR_ALERT_FATAL;
+	}
+	
+	/* Now select the most preferred protocol from the proposals. */
+	*out = APR_ARRAY_IDX(proposed_protos, 0, const unsigned char *);
+	for (i = 1; i < proposed_protos->nelts; ++i) {
+		const unsigned char *proto = APR_ARRAY_IDX(proposed_protos, i,
+												   const unsigned char*);
+		/* Do we prefer it over existing candidate? */
+		if (ssl_cmp_alpn_protos(c, *out, proto) < 0) {
+			*out = proto;
+		}
+	}
+	
+	size_t len = strlen((const char*)*out);
+	if (len > 255) {
+		ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(02306)
+					  "alpn negotiated protocol name too long");
+		return SSL_TLSEXT_ERR_ALERT_FATAL;
+	}
+	*outlen = (unsigned char)len;
+
+	return SSL_TLSEXT_ERR_OK;
+}
+
+#elif defined(HAVE_TLS_NPN)
 /*
  * This callback function is executed when SSL needs to decide what protocols
  * to advertise during Next Protocol Negotiation (NPN).  It must produce a
@@ -2159,18 +2289,18 @@
 
     /* If the connection object is not available, or there are no NPN
      * hooks registered, then there's nothing for us to do. */
-    if (c == NULL || sslconn->npn_advertfns == NULL) {
+    if (c == NULL || sslconn->alpn_proposefns == NULL) {
         return SSL_TLSEXT_ERR_OK;
     }
 
-    /* Invoke our npn_advertise_protos hook, giving other modules a chance to
+    /* Invoke our alpn_propose_proto hook, giving other modules a chance to
      * add alternate protocol names to advertise. */
     protos = apr_array_make(c->pool, 0, sizeof(char *));
-    for (i = 0; i < sslconn->npn_advertfns->nelts; i++) {
-        ssl_npn_advertise_protos fn = 
-            APR_ARRAY_IDX(sslconn->npn_advertfns, i, ssl_npn_advertise_protos);
+    for (i = 0; i < sslconn->alpn_proposefns->nelts; i++) {
+        ssl_alpn_propose_protos fn =
+            APR_ARRAY_IDX(sslconn->alpn_proposefns, i, ssl_alpn_propose_protos);
         
-        if (fn(c, protos) == DONE)
+        if (fn(c, NULL, protos) == DONE)
             break;
     }
     num_protos = protos->nelts;
diff -ru ./modules/ssl/ssl_private.h ./modules/ssl/ssl_private.h
--- ./modules/ssl/ssl_private.h	2015-01-16 16:51:56.000000000 +0100
+++ ./modules/ssl/ssl_private.h	2015-01-16 16:50:25.000000000 +0100
@@ -169,6 +169,11 @@
 #endif
 #endif
 
+/* ALPN Protocol Negotiation */
+#if OPENSSL_VERSION_NUMBER >= 0x10002000L && !defined(OPENSSL_NO_TLSEXT)
+#define HAVE_TLS_ALPN
+#endif
+
 /* Next Protocol Negotiation */
 #if !defined(OPENSSL_NO_NEXTPROTONEG) && defined(OPENSSL_NPN_NEGOTIATED)
 #define HAVE_TLS_NPN
@@ -443,8 +448,8 @@
 
 #ifdef HAVE_TLS_NPN
     /* Poor man's inter-module optional hooks for NPN. */
-    apr_array_header_t *npn_advertfns; /* list of ssl_npn_advertise_protos callbacks */
-    apr_array_header_t *npn_negofns; /* list of ssl_npn_proto_negotiated callbacks. */
+    apr_array_header_t *alpn_proposefns; /* list of ssl_alpn_propose_protos callbacks */
+    apr_array_header_t *alpn_negofns; /* list of ssl_alpn_proto_negotiated callbacks. */
 #endif
 
     server_rec *server;
@@ -797,7 +802,14 @@
 int         ssl_callback_SessionTicket(SSL *, unsigned char *, unsigned char *,
                                        EVP_CIPHER_CTX *, HMAC_CTX *, int);
 #endif
+
+#ifdef HAVE_TLS_ALPN
+int ssl_callback_alpn_select(SSL *ssl, const unsigned char **out,
+							 unsigned char *outlen, const unsigned char *in,
+							 unsigned int inlen, void *arg);
+#elif defined(HAVE_TLS_NPN)
 int ssl_callback_AdvertiseNextProtos(SSL *ssl, const unsigned char **data, unsigned int *len, void *arg);
+#endif
 
 /**  Session Cache Support  */
 apr_status_t ssl_scache_init(server_rec *, apr_pool_t *);

